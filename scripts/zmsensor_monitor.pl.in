#!/usr/bin/perl -wT
#
# ==========================================================================
#
# ZoneMinder Sensors Monitor Script
# Copyright (C) 2019 ZoneMinder LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# ==========================================================================

use strict;

# Include from system perl paths only
use Getopt::Long;
use autouse 'Pod::Usage'=>qw(pod2usage);

$| = 1;

$ENV{PATH}  = '/bin:/usr/bin:/usr/local/bin';
$ENV{SHELL} = '/bin/sh' if exists $ENV{SHELL};
delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};


my $arg_string = join(' ', @ARGV);

my %options;

my $zm_terminate = 0;
my $daemon = 0;
my $server_id;
my $version = 0;

GetOptions(
  daemon        =>\$daemon,
  'server_id=s' =>\$server_id,
  version       =>\$version,
) or pod2usage(-exitstatus => -1);

use ZoneMinder;
if ( $version ) {
  print ZoneMinder::Base::ZM_VERSION . "\n";
  exit(0);
}
logInit($server_id?(id=>'zmsensor_monitor_'.$server_id):());
sub HupHandler {
  # This idea at this time is to just exit, freeing up the memory.
  # zmfilter.pl will be respawned by zmdc.
  TermHandler();
  return;

  Info('Received HUP, reloading');
  ZoneMinder::Object::init_cache();
  &ZoneMinder::Logger::logHupHandler();
}
sub TermHandler {
  Info('Received TERM, exiting');
  $zm_terminate = 1;
}
sub Term {
  exit(0);
}
$SIG{HUP} = \&HupHandler;
$SIG{TERM} = \&TermHandler;
$SIG{INT} = \&TermHandler;

require LWP;
require XML::Hash::LX;
use Data::Dumper;
use Time::HiRes qw{ gettimeofday tv_interval usleep };
require ZoneMinder::Control;
require ZoneMinder::Sensor_Server;
require ZoneMinder::Sensor;
require ZoneMinder::Sensor_Action;
require ZoneMinder::Sensor_Action_Type;

my $browser = LWP::UserAgent->new();
my %Alarm_Types = map { $$_{TypeId} => $$_{Name} } ZoneMinder::Sensor_Action_Type->find();
Debug("Found " . %Alarm_Types . ' alarm types');

while (!$zm_terminate) {

	my $poll_start = [gettimeofday()];

	my @Servers = ZoneMinder::Sensor_Server->find($server_id?(Id=>$server_id):());
	if ( ! @Servers ) {
		die " Found no servers";
	}
  foreach my $Server ( @Servers ) {
    if ( !$Server->Url() ) {
      Error("No url configured for Sensor Server $$Server{Name}");
      next;
    }

    my $response = $browser->get($Server->Url());
    if ( !$response->is_success ) {
      Warning("Failed getting xml chain data from $$Server{Url}: ".$response->status_line);
    } else {
      if ( !$response->content() ) {
	      Warning("No Content");
	      next;
      }
      #Debug($response->content());
      my $xml = XML::Hash::LX::xml2hash($response->content());
      if ( !($xml and $$xml{response}) ) {
        Warning("Error getting xml chain data from $$Server{Url}");
        Data::Dumper->Dump($xml);
      } else {
        my $response = $$xml{response};
      	#Data::Dumper::Dump($xml);

        # Since we can have conflicting sensors, we will build up a list of actions to take for each Monitor.
        # Then iterate over them and perform the ones with the highest value.
        my %Monitor_Actions;
        
        foreach my $chain ( keys %{$response} ) {
          #Debug("Handling chain $chain $$response{$chain}");
          my $chain_data = $$response{$chain};
          my ($chain_name, $chain_id) = $chain =~ /^(\w+)(\d)$/;
          my @Sensors = ZoneMinder::Sensor->find(
            SensorServerId=>$$Server{Id},
            Chain=>$chain_id);
          my %Sensors_By_SensorId = map { $$_{SensorId}, $_ }  @Sensors;
          my %Sensors_By_Id = map { $$_{Id}, $_ }  @Sensors;

          foreach my $sensor_value ( $chain_data =~ /(#\d+!)/g ) {
            my ( $type_id, $sensor_id, $value ) = ( $sensor_value =~ /^#(\d\d)(\d\d)(\d\d)!$/ );
            if ( ! $Sensors_By_SensorId{$sensor_id} ) {
              if ( $Sensors_By_SensorId{1*$sensor_id} ) {
                $sensor_id *= 1;
              } else {
                Debug("No sensors found for $sensor_id on chain $chain_id $chain_name");
                next;
              }
            }
            if ( ! $Alarm_Types{$type_id} ) {
              Warning("Unknown alarm type! $type_id");
            }

            Debug("Type id: $type_id $Alarm_Types{$type_id} sensor id: $sensor_id value: $value");
            my @Actions = 
            ZoneMinder::Sensor_Action->find(
              'MinSensorId is null or <=' =>  $Sensors_By_SensorId{$sensor_id}{Id},
              'MaxSensorId is null or >=' =>  $Sensors_By_SensorId{$sensor_id}{Id},
              TypeId    =>  1*$type_id,
              'MinValue is null or <='=> $value,
              'MaxValue is null or >='=> $value,
            );
            if ( ! @Actions ) {
              Debug("No actions for Sesnors $sensor_id type $type_id for value $value");
            }
            foreach my $SA (@Actions ) {
              if ( ! $Sensors_By_Id{$$SA{SensorId}} ) {
                Debug("Sensor $$SA{SensorId} Not found for Chain $chain");
                next;
              }
              $Monitor_Actions{$$SA{MonitorId}} = [] if ! $Monitor_Actions{$$SA{MonitorId}};
              push @{$Monitor_Actions{$$SA{MonitorId}}}, {Value=>$value, Action=>$SA};
            } # end foreach Sensor_Action

          } # end foreach sensor_value
        } # end foreach chain

        foreach my $MonitorId ( keys %Monitor_Actions ) {
          Debug("Actions for monitor $MonitorId");
          my @Sorted_Actions = sort { $$a{Value} <=> $$b{Value} } @{$Monitor_Actions{$MonitorId}};

          foreach my $SSA ( @Sorted_Actions ) {
            my $SA = $$SSA{Action};
            Debug("Have $$SSA{Value} " . $SA->to_string());
          }
          my $SSA = $Sorted_Actions[0];
          my $SA = $$SSA{Action};

          Debug("Performing $$SA{Action}");

          $SA->do();
        } # end foreach Monitor in %Monitor_Actions
      } #end if valid response
    } # end have response

    if ( !$daemon ) {
      $zm_terminate = 1;
      next;
    }

    my $elapsed = tv_interval($poll_start);
    Debug("Elapsed: $elapsed");
    my $sleep_seconds = ($Server->PollFrequency() - $elapsed);
    usleep(1000000 * $sleep_seconds) if $sleep_seconds > 0;

  } # end foreach Sensor Server
} # end while main loop

exit(0);

1;
__END__

=head1 NAME

zmcontrol.pl - ZoneMinder control script

=head1 SYNOPSIS

 zmcontrol.pl --id {monitor_id} [--command={command}] [various options]

=head1 DESCRIPTION

FIXME FIXME

=head1 OPTIONS

 --autostop          -
 --xcoord [ arg ]    - X-coord
 --ycoord [ arg ]    - Y-coord
 --speed [ arg ]     - Speed
 --step [ arg ]      -
 --panspeed [ arg ]  -
 --panstep [ arg ]   -
 --tiltspeed [ arg ] -
 --tiltstep [ arg ]  -
 --preset [ arg ]    -

=cut
